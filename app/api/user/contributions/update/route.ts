// app/api/user/contributions/update/route.ts
import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { randomBytes } from "crypto";
import { redis } from "@/lib/redis";
import { connectDB } from "@/lib/db";
import User from "@/models/User";
import { decryptToken } from "@/lib/crypto";
import { Octokit } from "@octokit/rest";

type Patch = { date: string; count: number };

// small sleep to throttle commit creation (ms)
const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

function genRepoName() {
  // random-ish name: contrib-art-<6 hex>
  return `contrib-art-${randomBytes(3).toString("hex")}`;
}

function isoDateOrNull(s: unknown): string | null {
  if (typeof s !== "string") return null;
  const parsed = new Date(s);
  if (Number.isNaN(parsed.getTime())) return null;
  // return YYYY-MM-DD
  return parsed.toISOString().slice(0, 10);
}

// ensure request body is valid array of {date,count}
function validatePayload(body: any): Patch[] | null {
  if (!Array.isArray(body)) return null;
  const out: Patch[] = [];
  for (const item of body) {
    if (!item || typeof item !== "object") return null;
    const dateStr = isoDateOrNull(item.date);
    const count = Number(item.count);
    if (!dateStr) return null;
    if (!Number.isFinite(count) || count < 0) return null;
    out.push({ date: dateStr, count: Math.floor(count) });
  }
  return out;
}

export async function POST(request: Request) {
  try {
    // 1) auth via httpOnly cookie
    const cookieStore = await cookies();
    const sid = cookieStore.get("sid")?.value;
    if (!sid) {
      return NextResponse.json({ error: "missing session cookie" }, { status: 401 });
    }

    // 2) parse body
    const body = await request.json().catch(() => null);
    const patches = validatePayload(body);
    if (!patches) {
      return NextResponse.json(
        { error: "invalid payload — expected [{date: 'YYYY-MM-DD', count: number}, ...]" },
        { status: 400 }
      );
    }

    // 3) session -> githubId (Redis), then DB lookup
    const githubId = await redis.get<string>(sid);
    if (!githubId) return NextResponse.json({ error: "session not found" }, { status: 401 });

    await connectDB();
    const user = await User.findOne({ githubId }).exec();
    if (!user) return NextResponse.json({ error: "not authenticated" }, { status: 401 });

    // require that we have a verified email (commits need author.email associated to count)
    const authorEmail = (user.email as string | undefined) ?? null;
    if (!authorEmail) {
      return NextResponse.json({
        error: "no verified email on file. Please make your email available in GitHub or re-authenticate.",
      }, { status: 400 });
    }

    // decrypt token and init octokit
    const rawToken = decryptToken(user.encryptedToken);
    const octokit = new Octokit({ auth: rawToken });

    // 4) ensure repo exists (create if not)
    let repoName = (user.repoName as string | undefined) || null;
    let repoOwner = user.login;
    let repoHtmlUrl = (user.repoUrl as string | undefined) || null;
    let defaultBranch = "main";

    if (!repoName) {
      // create a new public repo in user's account
      repoName = genRepoName();
      const createResp: any = await octokit.request("POST /user/repos", {
        name: repoName,
        description: "Generated by contribution-art tool",
        private: false,
        auto_init: true, // initialize with README (so default branch exists)
      });
      repoOwner = createResp.data.owner.login;
      repoHtmlUrl = createResp.data.html_url;
      defaultBranch = createResp.data.default_branch ?? "main";

      // persist repoName + repoUrl in user doc
      user.repoName = repoName;
      user.repoUrl = repoHtmlUrl;
      await user.save();
    } else {
      // fetch repo to get default branch and ensure exists
      try {
        const repoResp: any = await octokit.request("GET /repos/{owner}/{repo}", {
          owner: repoOwner,
          repo: repoName,
        });
        defaultBranch = repoResp.data.default_branch || defaultBranch;
        repoHtmlUrl = repoResp.data.html_url || repoHtmlUrl;
      } catch (err) {
        // repo may have been deleted; create new one
        repoName = genRepoName();
        const createResp: any = await octokit.request("POST /user/repos", {
          name: repoName,
          description: "Generated by contribution-art tool",
          private: false,
          auto_init: true,
        });
        repoOwner = createResp.data.owner.login;
        repoHtmlUrl = createResp.data.html_url;
        defaultBranch = createResp.data.default_branch ?? "main";
        user.repoName = repoName;
        user.repoUrl = repoHtmlUrl;
        await user.save();
      }
    }

    // 5) For each date, create `count` commits — update README.md each commit
    const summary: { date: string; requested: number; created: number }[] = [];

    for (const p of patches) {
      const targetDate = p.date; // YYYY-MM-DD
      const countWanted = p.count;
      if (countWanted <= 0) {
        summary.push({ date: targetDate, requested: countWanted, created: 0 });
        continue;
      }

      // --- prepare per-date state: fetch current README and base commit/tree ---
      // default README header if absent
      let currentReadme = "# Contribution Art\n\n";

      try {
        const readmeResp: any = await octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: repoOwner,
          repo: repoName,
          path: "README.md",
          ref: defaultBranch,
        });

        if (readmeResp?.data?.content) {
          currentReadme = Buffer.from(readmeResp.data.content, "base64").toString("utf8");
        }
      } catch (e: any) {
        // If not found (404) we'll create it when committing; ignore other errors for now.
        // console.warn("readme fetch error (may be missing):", e?.message ?? e);
      }

      // get starting ref & commit/tree sha (we will update these as we make commits)
      const refName = `heads/${defaultBranch}`;
      const startRefResp: any = await octokit.request("GET /repos/{owner}/{repo}/git/ref/{ref}", {
        owner: repoOwner,
        repo: repoName,
        ref: refName,
      });
      let baseCommitSha: string = startRefResp.data.object.sha;

      const startCommitResp: any = await octokit.request("GET /repos/{owner}/{repo}/git/commits/{commit_sha}", {
        owner: repoOwner,
        repo: repoName,
        commit_sha: baseCommitSha,
      });
      let baseTreeSha: string = startCommitResp.data.tree.sha;

      let createdForThisDate = 0;

      // generate commits by repeatedly updating README
      for (let i = 0; i < countWanted; i++) {
        // Unique commit timestamp (midday + i seconds)
        const commitDate = new Date(`${targetDate}T12:00:00Z`);
        commitDate.setSeconds(commitDate.getSeconds() + i);

        // Append a new line to README content so every commit has different tree
        const timeIso = new Date().toISOString();
        const line = `- ${targetDate} commit #${i + 1} @ ${timeIso}\n`;
        const newReadmeContent = currentReadme + line;

        // 1) create blob for new README content
        const createBlobResp: any = await octokit.request("POST /repos/{owner}/{repo}/git/blobs", {
          owner: repoOwner,
          repo: repoName,
          content: Buffer.from(newReadmeContent).toString("base64"),
          encoding: "base64",
        });

        // 2) create tree that replaces README.md using base_tree to avoid clobbering other files
        const createTreeResp: any = await octokit.request("POST /repos/{owner}/{repo}/git/trees", {
          owner: repoOwner,
          repo: repoName,
          base_tree: baseTreeSha,
          tree: [
            {
              path: "README.md",
              mode: "100644",
              type: "blob",
              sha: createBlobResp.data.sha,
            },
          ],
        });

        // 3) create commit with author metadata and the new tree
        const createCommitResp: any = await octokit.request("POST /repos/{owner}/{repo}/git/commits", {
          owner: repoOwner,
          repo: repoName,
          message: `Contribution-art: ${targetDate} (${i + 1}/${countWanted})`,
          tree: createTreeResp.data.sha,
          parents: [baseCommitSha],
          author: {
            name: user.name || user.login,
            email: authorEmail,
            date: commitDate.toISOString(),
          },
        });

        // 4) update the branch ref to point to the new commit
        await octokit.request("PATCH /repos/{owner}/{repo}/git/refs/{ref}", {
          owner: repoOwner,
          repo: repoName,
          ref: refName,
          sha: createCommitResp.data.sha,
        });

        // 5) update local state so next iteration builds on latest commit
        baseCommitSha = createCommitResp.data.sha;
        baseTreeSha = createTreeResp.data.sha;
        currentReadme = newReadmeContent;

        createdForThisDate++;
        // polite pause to avoid hammering the API
        await sleep(300);
      } // end commits for day

      summary.push({ date: targetDate, requested: countWanted, created: createdForThisDate });
    } // end patches loop

    return NextResponse.json({
      ok: true,
      repo: { owner: repoOwner, name: repoName, url: repoHtmlUrl },
      summary,
    });
  } catch (err: any) {
    console.error("contribution update failed:", err);
    return NextResponse.json({ error: err?.message ?? "internal" }, { status: 500 });
  }
}
