import { cookies } from "next/headers";
import { randomBytes } from "crypto";
import { redis } from "@/lib/redis";
import { connectDB } from "@/lib/db";
import User from "@/models/User";
import { decryptToken } from "@/lib/crypto";
import { Octokit } from "@octokit/rest";
import { ReadableStream } from 'stream/web';

type Patch = { date: string; count: number };

// small sleep to throttle commit creation (ms)
const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

function genRepoName() {
  // random-ish name: contrib-art-<6 hex>
  return `contrib-art-${randomBytes(3).toString("hex")}`;
}

function isoDateOrNull(s: unknown): string | null {
  if (typeof s !== "string") return null;
  const parsed = new Date(s);
  if (Number.isNaN(parsed.getTime())) return null;
  // return YYYY-MM-DD
  return parsed.toISOString().slice(0, 10);
}

// ensure request body is valid array of {date,count}
function validatePayload(body: any): Patch[] | null {
  if (!Array.isArray(body)) return null;
  const out: Patch[] = [];
  for (const item of body) {
    if (!item || typeof item !== "object") return null;
    const dateStr = isoDateOrNull(item.date);
    const count = Number(item.count);
    if (!dateStr) return null;
    if (!Number.isFinite(count) || count < 0) return null;
    out.push({ date: dateStr, count: Math.floor(count) });
  }
  return out;
}

export async function POST(request: Request) {
  const encoder = new TextEncoder();

  const stream = new ReadableStream({
    async start(controller) {
      function send(message: any) {
        controller.enqueue(encoder.encode(`data: ${JSON.stringify(message)}\n\n`));
      }

      try {
        // 1) auth via httpOnly cookie
        const cookieStore = await cookies();
        const sid = cookieStore.get("sid")?.value;
        if (!sid) {
          send({ type: 'error', error: "missing session cookie" });
          controller.close();
          return;
        }

        // 2) parse body
        const body = await request.json().catch(() => null);
        const patches = validatePayload(body);
        if (!patches) {
          send({ type: 'error', error: "invalid payload — expected [{date: 'YYYY-MM-DD', count: number}, ...]" });
          controller.close();
          return;
        }

        // 3) session -> githubId (Redis), then DB lookup
        const githubId = await redis.get<string>(sid);
        if (!githubId) {
          send({ type: 'error', error: "session not found" });
          controller.close();
          return;
        }

        await connectDB();
        const user = await User.findOne({ githubId }).exec();
        if (!user) {
          send({ type: 'error', error: "not authenticated" });
          controller.close();
          return;
        }

        // require that we have a verified email (commits need author.email associated to count)
        const authorEmail = (user.email as string | undefined) ?? null;
        if (!authorEmail) {
          send({ type: 'error', error: "no verified email on file. Please make your email available in GitHub or re-authenticate." });
          controller.close();
          return;
        }

        // decrypt token and init octokit
        const rawToken = decryptToken(user.encryptedToken);
        const octokit = new Octokit({ auth: rawToken });

        // 4) ensure repo exists (create if not)
        const repoName = genRepoName();
        const createResp: any = await octokit.request("POST /user/repos", {
          name: repoName,
          description: "Generated by designer tool",
          private: false,
          auto_init: true, // initialize with README (so default branch exists)
        });
        const repoOwner = createResp.data.owner.login;
        const repoHtmlUrl = createResp.data.html_url;
        const defaultBranch = createResp.data.default_branch ?? "main";

        send({ type: 'repo_created', repo: { owner: repoOwner, name: repoName, url: repoHtmlUrl } });

        // 5) For each date, create `count` commits — update README.md each commit
        const summary: { date: string; requested: number; created: number }[] = [];

        for (const p of patches) {
          const targetDate = p.date; // YYYY-MM-DD
          const countWanted = p.count;

          send({ type: 'date_start', date: targetDate, requested: countWanted });

          if (countWanted <= 0) {
            summary.push({ date: targetDate, requested: countWanted, created: 0 });
            send({ type: 'date_done', date: targetDate, created: 0 });
            continue;
          }

          // --- prepare per-date state: fetch current README and base commit/tree ---
          // default README header if absent
          let currentReadme = "# Contribution Art\n\n";

          try {
            const readmeResp: any = await octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
              owner: repoOwner,
              repo: repoName,
              path: "README.md",
              ref: defaultBranch,
            });

            if (readmeResp?.data?.content) {
              currentReadme = Buffer.from(readmeResp.data.content, "base64").toString("utf8");
            }
          } catch (e: any) {
            // If not found (404) we'll create it when committing; ignore other errors for now.
            // console.warn("readme fetch error (may be missing):", e?.message ?? e);
          }

          // get starting ref & commit/tree sha (we will update these as we make commits)
          const refName = `heads/${defaultBranch}`;
          const startRefResp: any = await octokit.request("GET /repos/{owner}/{repo}/git/ref/{ref}", {
            owner: repoOwner,
            repo: repoName,
            ref: refName,
          });
          let baseCommitSha: string = startRefResp.data.object.sha;

          const startCommitResp: any = await octokit.request("GET /repos/{owner}/{repo}/git/commits/{commit_sha}", {
            owner: repoOwner,
            repo: repoName,
            commit_sha: baseCommitSha,
          });
          let baseTreeSha: string = startCommitResp.data.tree.sha;

          let createdForThisDate = 0;

          // generate commits by repeatedly updating README
          for (let i = 0; i < countWanted; i++) {
            // Unique commit timestamp (midday + i seconds)
            const commitDate = new Date(`${targetDate}T12:00:00Z`);
            commitDate.setSeconds(commitDate.getSeconds() + i);

            // Append a new line to README content so every commit has different tree
            const timeIso = new Date().toISOString();
            const line = `- ${targetDate} commit #${i + 1} @ ${timeIso}\n`;
            const newReadmeContent = currentReadme + line;

            // 1) create blob for new README content
            const createBlobResp: any = await octokit.request("POST /repos/{owner}/{repo}/git/blobs", {
              owner: repoOwner,
              repo: repoName,
              content: Buffer.from(newReadmeContent).toString("base64"),
              encoding: "base64",
            });

            // 2) create tree that replaces README.md using base_tree to avoid clobbering other files
            const createTreeResp: any = await octokit.request("POST /repos/{owner}/{repo}/git/trees", {
              owner: repoOwner,
              repo: repoName,
              base_tree: baseTreeSha,
              tree: [
                {
                  path: "README.md",
                  mode: "100644",
                  type: "blob",
                  sha: createBlobResp.data.sha,
                },
              ],
            });

            // 3) create commit with author metadata and the new tree
            const createCommitResp: any = await octokit.request("POST /repos/{owner}/{repo}/git/commits", {
              owner: repoOwner,
              repo: repoName,
              message: `Contribution-art: ${targetDate} (${i + 1}/${countWanted})`,
              tree: createTreeResp.data.sha,
              parents: [baseCommitSha],
              author: {
                name: user.name || user.login,
                email: authorEmail,
                date: commitDate.toISOString(),
              },
            });

            // 4) update the branch ref to point to the new commit
            await octokit.request("PATCH /repos/{owner}/{repo}/git/refs/{ref}", {
              owner: repoOwner,
              repo: repoName,
              ref: refName,
              sha: createCommitResp.data.sha,
            });

            // 5) update local state so next iteration builds on latest commit
            baseCommitSha = createCommitResp.data.sha;
            baseTreeSha = createTreeResp.data.sha;
            currentReadme = newReadmeContent;

            createdForThisDate++;
            send({ type: 'commit_created', date: targetDate, index: i + 1 });
            // polite pause to avoid hammering the API
            await sleep(300);
          } // end commits for day

          summary.push({ date: targetDate, requested: countWanted, created: createdForThisDate });
          send({ type: 'date_done', date: targetDate, created: createdForThisDate });
        } // end patches loop

        send({ type: 'done', summary, repo: { owner: repoOwner, name: repoName, url: repoHtmlUrl } });
        controller.close();
      } catch (err: any) {
        console.error("contribution update failed:", err);
        send({ type: 'error', error: err?.message ?? "internal" });
        controller.close();
      }
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
